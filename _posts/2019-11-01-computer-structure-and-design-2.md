---
published: true
layout: single
title: "컴퓨터 구조 및 설계 2장"
category: book
tags: [Computer Organization and Design]
comments: false
---

# 2장 명령어: 컴퓨터 언어

## 2.2 하드웨어 연산

### MIPS 산술 명령어

- 반드시 한 종류의 연산만 지시한다.
- 항상 변수 세 개를 갖는 형식을 지킨다.
- ex) b,c,d,e의 합을 a에 넣기
  ```bash
  add a, b, c     # a = b + c
  add a, a, d     # a = a + d
  add a, a, e     # a = a + e
  ```
- 한 줄에 명령어 하나만 쓸 수 있다.
- 줄이 끝나면 주석도 끝난다.

> **하드웨어 설계 원칙 1**  
> 간단하게 하기 위해서는 규칙적인 것이 좋다.

## 2.3 피연산자

- 산술 명령어의 피연산자에는 제약이 있다.
  - 레지스터(register)라고 하는 하드웨어로 직접 구현된 특수 위치 몇 곳에 있는 것만을 사용할 수 있다.
    - MIPS 구조에서 레지스터의 크기는 32비트 = 워드(word)
  - MIPS 언어를 단계적으로 구체화할 때, 산술 명령어의 각 피연산자는 32개의 32비트 레지스터 중 하나이어야 한다.
    - 레지스터는 개수가 한정되어 있다.
    - 레지스터의 개수를 32개로 제한하는 이유?
      - 레지스터가 아주 많아지면, 전기 신호가 더 멀리까지 전달되어야 하므로 클럭 사이클 시간이 길어진다.
      - 레지스터가 사용하는 비트 수와 관련 있다.

> **하드웨어 설계 원칙 2**  
> 작은 것이 더 빠르다.

하지만, "작은 것이 더 빠르다"가 절대적인 것은 아니다. 예를 들어 레지스터를 31개로 한다고 해서 32개보다 빨라지지는 않는다.

레지스터 번호 0부터 31까지를 사용하여 명령어를 작성하지만 레지스터를 나타내기 위해서 MIPS 관례는 달러 기호 뒤에 두 글자가 따라 나오는 이름을 사용한다.

ex) `f = (g + h) - (i + j);` 에서 컴파일러가 변수 f,g,h,i,j를 레지스터 $s0,$s1,$s2,$s3,\$s4에 각각 할당했다고 할 때, 컴파일된 MIPS 코드는?

```bash
add $t0, $s1, $s2       # t0 = g + h
add $t1, $s3, $s4       # t1 = i + j
sub $s0, $t0, $t1       # f = t0 - t1
```

### 메모리 피연산자

프로세서는 소량의 데이터만을 레지스터에 저장할 수 있다. 하지만, 컴퓨터 메모리는 수십억 개의 데이터를 저장할 수 있다. 그러므로 배열이나 구조체 같은 자료 구조는 메모리에 보관한다.

MIPS의 산술연산은 레지스터에서만 실행되기 때문에 메모리와 레짓터 간에 데이터를 주고 받는 명령가 있어야 한다. 이를 **데이터 전송 명령어(data transfer instruction)**이라 한다.  
메모리에 기억된 데이터 워드에 접근하기 위해서는 명령어가 메모리 주소를 지정해야한다.  
메모리에서 레지스터로 데이터를 복사해 오는 데이터 전송 명령을 적재(load)라 한다. 이때, 적재 명령은 연산자 이름, 메모리에서 읽어 온 값을 저장할 레지스터, 메모리 접근에 사용할 상수와 레지스터로 구성된다. MIPS에서 이 명령어의 실제 이름은 **lw(load word)**이다.

ex) A는 100워드 배열이고, 변수 g,h는 레지스터 $s1, $s2에 할당되었다고 가정한다. 또 배열 A의 시작 주소(base address)가 \$s3에 기억되어있다고 할 때, `g = h + A[8]` 컴파일하라.

```bash
lw $t0, 8($s3)          # t0에 A[8]값을 넣는다.
add $s1, $s2, $t0       # g = h + t0
```

여기서 데이터 전송 명령어의 상수 부분을 **변위(offset)**라 하고, 주소 계산을 위해 여기에 더해지는 레지스터를 베이스 레지스터(base register)라고 한다.

워드 주소는 워드를 구성하는 4바이트 주소 중 하나를 사용한다. 그러므로 연속된 워드의 주소는 4씩 차이가 난다.
즉, MIPS에서 워드의 시작 주소는 항상 4의 배수이어야 한다. 이는 **정렬 제약(alignment restriction)**이라고 한다.

MIPS는 최상위 바이트 주소를 워드 주소로 사용하는 빅엔디안(big-endian) 계열에 속한다.

레지스터에서 메모리로 데이터를 보내는 명령을 저장(store)이라 한다. 저장 명령도 적재 명령과 동일하게 연산자 이름, 메모리에서 읽어 온 값을 저장할 레지스터, 메모리 접근에 사용할 상수와 레지스터로 구성된다. MIPS에서 이 명령어의 실제 이름은 **sw(store word)**이다.

ex) 변수 h가 레지스터 $s2에 할당되어 있으며 배열 A의 시작 주소는 $s3에 들어 있다고 가정하자. `A[12] = h + A[8]`을 MIPS 어셈블리 프로그램으로 바꾸어라.

```bash
lw $t0, 32($s3)         # t0에 A[8]값을 넣는다. 이때, 워드 주소는 4씩 차이나기 때문에 4*8 = 32를 활용한다.
add $t0, $s2, $t0       # t0 = h + t0
sw $t0, 48($s3)         # A[12] = t0
```

컴퓨터가 가지고 있는 레지스터보다 프로그램에서 사용하는 변수가 더 많은 경우가 있다.
그렇기 때문에 컴파일러는 자주 사용되는 변수를 가능한 많이 레지스터에 넣고 나머지 변수는 메모리에 저장했다가 필요할 때 꺼내서 레지스터에 넣는다.
자주 사용하지 않는 변수를 메모리에 넣는 것을 레지스터 **스필링(spilling)**이라고 한다.

레지스터는 메모리보다 접근시간이 짧고 처리량도 많으므로, 레지스터에 저장된 데이터를 사용하면 시간이 절약되고 사용하기도 간편한다.
또한, 레지스터 접근은 메모리 접근보다 에너지도 적게 든다.

### 상수 또는 수치 피연산자

상수는 프로그램이 적재될 때 메모리에 넣어진다. 그래서 상수를 사용하려면 메모리에서 상수를 읽어와야한다.  
이때, 적재 명령을 사용하지 않는 방법 중 하나는 상수 필드를 갖는 산술 명령어를 제공하는 것이다. 여기서 상수를 **수치(immediate) 피연산자**라고 한다.
이는 매번 메모리에서 상수를 가져오는 것보다 연산이 빨라지고 에너지 소모가 줄어든다.

ex) 레지스터 \$s3에 4를 더하기

```bash
addi $s3, $s3, 4
```

상수 0은 유용한 여러 변형을 제공함으로써 단순한 명령어 집합을 가능케 한다. 예를 들면, 복사(move) 연산은 피연산자 중 하나가 0인 add 명령어이다.

## 2.4 부호있는 수와 부호없는 수
