---
published: true
layout: single
title: "컴퓨터 구조 및 설계 3장"
category: book
tags: [Computer Organization and Design]
comments: false
---

# 3장 컴퓨터 연산

## 3.2 덧셈과 뺄셈

### 오버플로가 발생하지 않는 경우

- 덧셈에서 부호가 다른 피연산자를 더할 경우
  - 두 피연산자 중 어느 하나보다는 커질 수 없기 때문
- 뺄셈에서는 부호가 같을 경우
  - 같은 부호의 수를 빼는 것 = 부호가 다른 수를 더하는 것

### 오버플로가 발생하는 경우

- 올림수가 부호 비트로 올라간 경우
  - 두 양수를 더한 값이 음수가 되는 경우
  - 두 음수를 더했는데 합이 양수가 되는 경우
- 부호 비트에서 빌림수가 발생한 경우
  - 양수에서 음수를 뺀 결과가 음수인 경우
  - 음수에서 양수를 뺀 결과가 양수인 경우

MIPS는 오버플로를 탐지하면 예외(exception)를 발생시킨다. 예외를 인터럽트(interrupt)라고 부르기도 한다. 오버플로가 발생한 명령어의 주소는 레지스터에 저장되고, 컴퓨터는 적절한 처리를 하기 위해서 해당 루틴으로 점프한다. 인터럽트가 걸린 주소를 저장해, 해당 처리를 한 다음에 프로그램 실행을 계속할 수 있게 한다.  
MIPS에는 EPC(Exception Program Counter)라고 불리는 레지스터가 있어 인터럽트가 걸린 명령어의 주소를 기억하는데 이용된다. mfc0(move from system control) 명령어는 EPC를 범용 레지스터에 복사해, MIPS 소프트웨어가 점프 레지스터 명령어를 통해 인터럽트가 걸린 명령어로 되돌아갈 수 있게 해준다.

## 3.3 곱셈

- **피승수(multiplicand)**: 첫 번째 피연산자
- **승수(multiplier)**: 두 번째 피연산자
- **곱(product)**: 최종 결과

### 곱셈 알고리즘과 하드웨어의 순차적 버전

1. 승수의 최하위 비트를 통해 피승수를 곱 레지스터에 더할지 말지를 결정한다.
   - 승수의 자리 수가 1이면 피승수를 곱에 더한다.
   - 승수의 자리 수가 0이면 2단계로 넘어간다. (0이기 때문)
2. 피승수를 왼쪽으로 자리이동한다.
3. 승수를 오른쪽으로 자리이동한다.

ex) 4비트 수 0010 _ 0011를 구하라
![0010 _ 0011](/assets/images/multiply_example.PNG)
여기서 피승수 레지스터, 곱 레지스터는 8비트이지만, 승수 레지스터는 4비트이다. 피승수는 승수의 비트만큼 왼쪽으로 이동해야하기 때문에, 피승수의 비트 4 + 승수의 비트 4 = 총 8비트가 필요하다. 또한, 곱 레지스터에 피승수를 더하기 때문에 동일하게 8비트를 가진다.

이 알고리즘과 하드웨어는 매 반복이 한 클럭 사이클만 걸리도록 쉽게 바꿀 수 있다. 연산을 병렬로 수행함으로써 속도 향상이 가능해진다. 승수 비트가 1일 때 피승수를 곱에 더하는 동안 승수와 피승수를 자리이동한다. 덧셈기와 레지스터에서 사용되지 않는 부분이 있기 때문에 폭을 절반으로 줄여(64bit -> 32bit) 더욱 최적화할 수 있다. 또한, 곱 레지스터가 64bit일 경우 승수를 곱 레지스터의 오른쪽 절반에 놓을 수 있다.

### 부호있는 곱셈

승수와 피승수를 양수로 변환해 계산하고, 피연사자들의 부호가 서로 다를 때만 곱을 음수로 바꾼다.

### 더 빠른 곱셈

승수의 32개 비트 각각을 조사하면, 곱셈을 시작하는 초기에 이미 피승수가 더해져야 하는지 아닌지를 알 수 있다. 즉, 승수의 매 비트마다 32비트 덧셈기를 하나씩 할당하면 더 빠른 곱셈이 가능하다.

#### 여러 방법들

1. 덧셈기의 한 입력은 피승수를 해당 승수 비트와 AND한 것이고 다른 입력은 앞 덧셈기의 출력이다.
2. 오른쪽 덧셈기의 출력을 왼쪽 덧셈기의 입력에 연결하여 32층의 덧셈기 스택을 만든다.
3. 32번의 덧셈을 병렬 트리구조로 만든다.

### MIPS에서의 곱셈

- mult: 부호가 있는 곱셈
- multu: 부호가 없는 곱셈
- mflo(move from lo)/mfhi(move from hi): 32비트 정수 곱을 범용 레지스터로 가져옴

multu 수행 결과 Hi가 0이거나, mult 수행결과 Hi가 Lo의 부호와 같은 비트 32개로 채워져 있다면, 오버플로가 아니다.

## 3.4 나눗셈

- **피제수(dividend)**: 나누어지는 수
- **제수(devisor)**: 피제수를 나누는 수
- 피제수 = 몫 \* 제수 + 나머지

### 나눗셈 알고리즘과 하드웨어

0. 레지스터를 초기화한다.
   - 몫(Quotient) 레지스터 32비트를 0으로 초기화해서 시작한다.
   - 제수는 매번 오른쪽으로 한 비트씩 자리이동시켜야 하기 때문에 64비트 제수 레지스터의 왼쪽 절반에 넣고 시작한다.
   - 나머지 레지스터는 피제수로 초기화된다.
1. 피제수 - 제수 결과값을 나머지 레지스터에 넣는다.
   - 제수가 피제수보다 작거나 같은지 확인하기 위해
1. 나머지 값이 양수인 경우 A, 음수인 경우 B
   - A: 몫에 1을 넣는다.
   - B: 몫에 0을 넣고 제수를 나머지 레지스터에 다시 더함으로써 원래의 값을 회복한다.
1. 제수는 오른쪽으로 자리이동한다.

ex) 4비트 수 0000 0111 나누기 0010를 구하라
![0111 / 0010](/assets/images/divide_example.PNG)

이 알고리즘과 하드웨어는 훨씬 더 빠르고 싸게 개선될 수 있다. 뺄셈과 동시에 피연산자의 몫을 자리이동시키면 성능 향상이 가능하다. 레지스터와 덧셈기에 사용되지 않는 부분이 있음을 활용하여 덧셈기와 레지스터 크기를 절반으로 줄일 수 있다. 또한, 몫 레지스터를 나머지 레지스터의 오른쪽 절반에 결합시켰다.

### 부호있는 나눗셈

제수와 피제수의 부호를 기억하고 이 부호들이 다른 경우에는 몫을 음수화한다.

#### 나머지의 부호

두 연산자의 부호가 다를 경우에는 몫의 부호를 음수로 하고, 나머지가 0이 아니면 나머지의 부호는 피제수의 부호를 따르게 한다.

### 더 빠른 나눗셈

나눗셈에서는 다음 단계를 수행하기 전에 뺄셈한 결과의 부호를 알아야 하기 때문에 곱셈과 같이 많은 수의 덧셈기를 사용해 속도를 빠르게 할 수 없다.

**SRT 나눗셈**은 각 단계에서 여러 개의 몫 비트를 예측하는 기법을 사용한다. 피제수와 나머지의 상위 비트들을 이용하여 표를 찾아서 몫을 추측하고, 틀린 추측은 그 후의 단계에서 바로잡는다.

### MIPS에서의 나눗셈

나눗셈 명령이 완료된 뒤 Hi는 나머지, Lo는 몫을 갖는다.

- div(divide): 부호있는 나눗셈
- divu(divide unsigned): 부호없는 나눗셈
- mflo/mfhi: 원하는 결과를 범용 레지스터에 넣는다.

### 나눗셈 알고리즘 종류

1. 비복원(nonrestoring) 나눗셈
   - 나머지가 음수인 경우, 음수 그대로 두고 다음 단계에서 자리이동된 나머지에 피제수를 더하는 방법
   - 각 단계마다 1사이클씩 소요
2. 복원(restoring) 나눗셈
   - 위에서 설명한 것과 같이 나머지가 음수인 경우, 제수를 바로 더해 원상 복구한다.
3. 조건부실행(nonperforming) 나눗셈
   - 뺄셈의 결과가 음수이면 이를 저장하지 않는다.
   - 평균적으로 1/3배 만큼 적은 수의 산술연산을 한다.

## 3.5 부동소수점
